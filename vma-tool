#!/usr/bin/env python3
#
# vma-tool - a toolbox for managing and optimizing Proxmox VMA files
#
# Copyright (c) 2025, Lars Gust√§bel
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# pylint:disable=invalid-name,too-many-instance-attributes,attribute-defined-outside-init

"""Manage and optimize Proxmox VMA (virtual machine archive) files.
"""

import io
import os
import sys
import time
import hashlib
import argparse
import tempfile

from struct import Struct
from uuid import UUID, uuid4

OPTIMIZED_UUID = bytes.fromhex("12345678aabbccddeeffaabbccddeeff")

VMA_CLUSTER_SIZE = 65536
VMA_HEADER_SIZE = 12288
VMA_EXTENT_HEADER_SIZE = 512
VMA_MAX_CONFIGS = 256
VMA_MAX_DEVICES = 256
VMA_BLOCKS_PER_EXTENT = 59


class EOF(EOFError):
    """An EOFError subclass that stores a file offset.
    """

    def __init__(self, offset):
        super().__init__()
        self.offset = offset

def md5(buf):
    """Calculate an md5 sum from a buffer.
    """
    return hashlib.md5(buf).digest()

def block512(n):
    """Round up <n> to a 512-block boundary.
    """
    return (n // 512 + 1) * 512

def split(s, sep):
    """Split a string <s> at <sep> into two parts.
    """
    return tuple(x.strip() for x in s.split(sep, 1))

def format_size(size):
    """Format <size> as a human-readable size.
    """
    for i, unit in enumerate(("TiB", "GiB", "MiB", "KiB", "B")):
        base = 1024 ** (4 - i)
        if size >= base:
            precision = 0 if unit == "B" else 1
            break
    return f"{size / base:.{precision}f} {unit}"

def safe_read(fobj, size):
    """Read <size> bytes from <fobj> and raise EOF if there was not enough data.
    """
    offset = fobj.tell()
    buf = fobj.read(size)
    if len(buf) != size:
        raise EOF(offset)
    return buf


class _Structure:
    """Represent a fixed-size structured binary buffer.
    """

    _struct = Struct("")

    def __init__(self):
        self._buf = io.BytesIO()

    @classmethod
    def read(cls, fobj):
        """Read and create an object from file object <fobj>.
        """
        return cls.from_buf(fobj.tell(), safe_read(fobj, cls._struct.size))

    @classmethod
    def from_buf(cls, offset, buf):
        """Create an object from a structured buffer.
        """
        assert len(buf) == cls._struct.size
        obj = cls.__new__(cls) # we don't call __init__()
        obj._offset = offset
        obj._buf = buf
        obj.parse(cls._struct.unpack(buf))
        return obj

    @classmethod
    def array_from_buf(cls, offset, buf):
        """Create a list of objects from a structured buffer.
        """
        assert len(buf) % cls._struct.size == 0
        a = []
        o = 0
        while o < len(buf):
            obj = cls.__new__(cls) # we don't call __init__()
            obj._offset = offset + o
            obj._buf = buf[o:o + cls._struct.size]
            obj.parse(cls._struct.unpack(obj._buf))
            o += cls._struct.size
            a.append(obj)
        return a

    # FIXME name
    def parse(self, record):
        """Initialize an instance from the values in <record>.
        """
        raise NotImplementedError

    # FIXME name
    def render(self):
        """Return a structured buffer representation of this instance.
        """
        raise NotImplementedError


class VMADeviceInfo(_Structure):
    """Block device information structure.
    """

    _struct = Struct("> I 4x Q 16x")

    def __init__(self, devname_ptr, size):
        super().__init__()

        self.devname_ptr = devname_ptr
        self.size = size

    def parse(self, record):
        self.devname_ptr, self.size = record

    def render(self):
        return self._struct.pack(self.devname_ptr, self.size)


class VMAHeader(_Structure):
    """Global vma file header structure.
    """

    _struct = Struct("> 4s I 16s Q 16s I I I 1984x 256I 256I 4x 8192s")

    def __init__(self, uuid, ctime=None):
        super().__init__()

        self.uuid = uuid
        self.ctime = ctime if ctime is not None else int(time.time())

        self.blob_buffer = BlobBuffer()
        self.config_names = []
        self.config_data = []
        self.dev_info = [VMADeviceInfo(0, 0)]

    @classmethod
    def read(cls, fobj):
        obj = cls.from_buf(fobj.tell(), safe_read(fobj, cls._struct.size))

        assert fobj.tell() == obj.blob_buffer_offset

        buf = safe_read(fobj, obj.header_size - obj.blob_buffer_offset)
        obj._buf += buf

        blob_buffer = BlobBuffer.from_buf(obj.blob_buffer_offset, buf[:obj.blob_buffer_size])

        obj.configurations = {}
        for name_ptr, data_ptr in zip(obj.config_names, obj.config_data):
            if name_ptr == 0:
                continue
            name = os.fsdecode(blob_buffer[name_ptr])
            data = blob_buffer[data_ptr]
            obj.configurations[name] = data

        obj.devices = {}
        for dev_id, dev in enumerate(obj.dev_info):
            if dev.size == 0:
                continue
            name = os.fsdecode(blob_buffer[dev.devname_ptr])
            obj.devices[dev_id] = (name, obj.dev_info[dev_id].size)

        if md5(obj._buf[:32] + b"\0" * 16 + obj._buf[48:]) != obj.md5sum:
            raise SystemExit(f"ERROR: corrupt file, damaged VMA header at 0x{obj._offset:x}!")

        return obj

    def parse(self, record):
        magic, version, self.uuid, self.ctime, self.md5sum, self.blob_buffer_offset, \
                self.blob_buffer_size, self.header_size = record[:8]

        self.config_names = record[8:264]
        self.config_data = record[264:520]
        dev_info_buf = record[520]

        self.dev_info = VMADeviceInfo.array_from_buf(self._offset - 8192, dev_info_buf)

        if magic != b"VMA\0":
            raise SystemExit("ERROR: not a VMA file")

        if version != 1:
            raise SystemExit("ERROR: only VMA version 1 is supported!")

    def add_config(self, name, data):
        """Add a configuration file to the blob buffer.
        """
        self.config_names.append(self.blob_buffer.add_string(name))
        self.config_data.append(self.blob_buffer.add_blob(data))

    def add_device(self, name, size):
        """Add a device name to the blob buffer.
        """
        self.dev_info.append(VMADeviceInfo(self.blob_buffer.add_string(name), size))

    def render(self):
        self.config_names += [0] * (VMA_MAX_CONFIGS - len(self.config_names))
        self.config_data += [0] * (VMA_MAX_CONFIGS - len(self.config_data))

        self.dev_info += [VMADeviceInfo(0, 0)] * (VMA_MAX_DEVICES - len(self.dev_info))
        dev_info_buf = b"".join(d.render() for d in self.dev_info)

        self._buf.write(self._struct.pack(b"VMA\0", 1, self.uuid, self.ctime, b"\0" * 16,
                                          VMA_HEADER_SIZE, self.blob_buffer.size,
                                          VMA_HEADER_SIZE + block512(self.blob_buffer.size),
                                          *self.config_names, *self.config_data, dev_info_buf))

        self._buf.write(self.blob_buffer.render())

        buf = self._buf.getbuffer()
        buf[32:48] = md5(buf)
        buf.release()
        return self._buf.getvalue()


class BlobBuffer(dict):
    """A dictionary holding the blobs.
    """

    _struct = Struct("<H")

    def __init__(self):
        self._buf = io.BytesIO()

    @property
    def size(self):
        """Return the size of the blob buffer.
        """
        return self._buf.tell()

    @classmethod
    def from_buf(cls, offset, buf):
        """Create an object from a structured buffer.
        """
        obj = cls()
        obj._offset = offset
        obj._buf = buf

        s = cls._struct.size
        o = 1 # skip the first byte
        while o < len(buf):
            size = cls._struct.unpack(buf[o:o + s])[0]
            obj[o] = buf[o + s:o + s + size].rstrip(b"\0")
            o += s + size
        return obj

    def add_string(self, s):
        """Add a null-terminated string to the blob buffer.
        """
        return self.add_blob(s + b"\0")

    def add_blob(self, s):
        """Add raw data to the blob buffer.
        """
        offset = self._buf.tell()
        if offset == 0:
            # There is one null-byte padding at the start of the blob buffer.
            self._buf.write(b"\0")
            offset = 1

        self._buf.write(self._struct.pack(len(s)))
        self._buf.write(s)
        return offset

    def render(self):
        """Return a structured buffer representation of this instance.
        """
        buf = self._buf.getvalue()
        return buf + b"\0" * (block512(len(buf)) - len(buf))


class Blockinfo(_Structure):
    """Structure that holds information about one cluster of data in an extent header.
    """

    _struct = Struct("> H x B I")

    def __init__(self, dev_id, cluster_num):
        super().__init__()

        self.mask = 0
        self.dev_id = dev_id
        self.cluster_num = cluster_num

        self.blocks = []

    def parse(self, record):
        self.mask, self.dev_id, self.cluster_num = record

    def iterate(self, fobj):
        """Iterate over the blocks of data in this Blockinfo. Holes are yielded as None values.
        """
        mask = self.mask
        for _ in range(16):
            if mask & 1:
                yield safe_read(fobj, 4096)
            else:
                yield None
            mask >>= 1

    def add(self, cluster):
        """Store a cluster of blocks.
        """
        for i in range(16):
            offset = i * 4096
            block = cluster[offset:offset+4096]

            if not block:
                # If a file does not line up to 65536 bytes,
                # we add "holes" at the end.
                block = b"\0" * 4096

            self.mask >>= 1
            if block.count(b"\0") != 4096:
                self.mask |= 1 << 15
                self.blocks.append(block)

        return len(self.blocks)

    def render(self):
        return self._struct.pack(self.mask, self.dev_id, self.cluster_num)


class VMAExtentHeader(_Structure):
    """Extent header that contains up to 59 clusters with 16 4096-byte-blocks each.
    """

    _struct = Struct("> 4s 2x H 16s 16s 472s")

    def parse(self, record):
        magic, self.block_count, self.uuid, self.md5sum, blockinfo_buf = record

        if magic != b"VMAE":
            raise SystemExit(f"ERROR: corrupt file, no VMA extent found at 0x{self._offset:x}!")

        if md5(self._buf[:24] + b"\0" * 16 + self._buf[40:]) != self.md5sum:
            raise SystemExit(f"ERROR: corrupt file, damaged VMA extent at 0x{self._offset:x}!")

        self.blockinfo = Blockinfo.array_from_buf(self._offset - 472, blockinfo_buf)

    def __init__(self, dev_id, uuid, cluster_num):
        super().__init__()

        self.dev_id = dev_id
        self.uuid = uuid
        self.cluster_num = cluster_num

        self.block_count = 0
        self.blockinfos = []

    def add(self, cluster):
        """Add a cluster of data to the extent.
        """
        blockinfo = Blockinfo(self.dev_id, self.cluster_num)
        self.block_count += blockinfo.add(cluster)
        self.cluster_num += 1
        self.blockinfos.append(blockinfo)
        return len(self.blockinfos) == VMA_BLOCKS_PER_EXTENT

    def render(self):
        # If there is no data, we do not need a VMA extent.
        if not self.blockinfos:
            return b""

        # First, build the table of blockinfo objects.
        blockinfo_buf = io.BytesIO()
        for i in range(VMA_BLOCKS_PER_EXTENT):
            try:
                blockinfo = self.blockinfos[i]
            except IndexError:
                # pylint:disable=protected-access
                blockinfo_buf.write(b"\0" * Blockinfo._struct.size)
            else:
                blockinfo_buf.write(blockinfo.render())

        # Build the header structure.
        self._buf.write(self._struct.pack(b"VMAE", self.block_count, self.uuid, b"\0" * 16,
                                          blockinfo_buf.getvalue()))

        buf = self._buf.getbuffer()
        buf[24:40] = md5(buf)
        buf.release()

        for blockinfo in self.blockinfos:
            for block in blockinfo.blocks:
                self._buf.write(block)

        return self._buf.getvalue()


class Config:
    """Store a qemu-server.conf configuration file data for access and modification.
    """

    def __init__(self, text):
        self.text = text

    def get(self, key, default=None):
        """Return the configuration value specified by <key>.
        """
        for line in self.text.decode("utf-8").splitlines():
            if line.startswith("#"):
                continue
            k, v = split(line, ":")
            if k == key:
                return v
        return default

    def set(self, key, value):
        """Modify the configuration <value> at <key>.
        """
        lines = []
        updated = False
        for line in self.text.decode("utf-8").splitlines():
            if not line or line.startswith("#"):
                lines.append(line)
            else:
                k, v = split(line, ":")
                if k == key:
                    updated = True
                    v = value
                lines.append(f"{k}: {v}")
        self.text = ("\n".join(lines) + "\n").encode("utf-8")
        return updated

    def getvalue(self):
        """Return the (modified) configuration file data.
        """
        return self.text


class VMAReader:
    """Read metadata and data from a Proxmox VMA file.
    """

    def __init__(self, fobj):
        self.fobj = fobj
        self.header = VMAHeader.read(self.fobj)

    def info(self):
        """Show detailed information about a VMA file.
        """
        print("filename:", self.fobj.name)
        print("uuid:", UUID(bytes=self.header.uuid))
        print("created:", time.asctime(time.localtime(self.header.ctime)))
        print("size:", format_size(os.fstat(self.fobj.fileno()).st_size))

        for name, config in self.header.configurations.items():
            if name == "qemu-server.conf":
                config = Config(config)
                print("name:", config.get("name", "<unset>"))

        ordered_blocks, optimized_uuid = self.check_optimized(1024**3)
        print("optimized:", end=" ")
        if ordered_blocks:
            if optimized_uuid:
                print("yes")
            else:
                print("partially")
        else:
            print("no")
        print()

        print("configurations:")
        for name, config in self.header.configurations.items():
            print(f"  {name} ({format_size(len(config))})")
        print()

        print("devices:")
        for dev_id, (name, size) in self.header.devices.items():
            print(f"  {dev_id}: {name} ({format_size(size)})")
        print()

    def check_optimized(self, bytes_to_read=None):
        """Check if the VMA file is optimized, i.e. if the data is ordered and if it uses the
           default uuid.
        """
        optimized_uuid = self.header.uuid == OPTIMIZED_UUID

        counter = {dev_id: 0 for dev_id in self.header.devices}
        cluster_num = {}
        while True:
            offset = self.fobj.tell()
            try:
                extent = VMAExtentHeader.read(self.fobj)
            except EOF as exc:
                # pylint:disable=raise-missing-from
                if exc.offset == offset:
                    break
                raise SystemExit(f"ERROR: corrupt file, short VMA extent at 0x{exc.offset:x}!")

            for blockinfo in extent.blockinfo:
                dev_id = blockinfo.dev_id

                if dev_id not in self.header.devices:
                    continue

                for _ in blockinfo.iterate(self.fobj):
                    pass

                if blockinfo.cluster_num != cluster_num.get(dev_id, 0):
                    counter[dev_id] += 1

                cluster_num[dev_id] = blockinfo.cluster_num + 1

            if bytes_to_read is not None and self.fobj.tell() >= bytes_to_read:
                break

        for c in counter.values():
            if c > 0:
                return False, optimized_uuid

        return True, optimized_uuid

    def unpack(self, directory, verbose, progress):
        """Extract all the configuration files and block device files to a <directory>.
        """
        # pylint:disable=consider-using-with
        try:
            os.makedirs(directory)
        except FileExistsError:
            pass

        for name, config in self.header.configurations.items():
            path = os.path.join(directory, name)
            if verbose:
                print("  extract config", name)
            with open(path + ".tmp", "wb") as dst:
                dst.write(config)
            os.rename(path + ".tmp", path)

        devices = {}
        sizes = {}
        try:
            for dev_id, (name, size) in self.header.devices.items():
                path = os.path.join(directory, name)
                devices[dev_id] = open(path + ".tmp", "wb")
                sizes[dev_id] = size
                if verbose:
                    print(f"  extract device {dev_id} ({format_size(size)})", name)

            self.extract_devices(devices, sizes, progress)

        finally:
            for dst in devices.values():
                dst.close()
                os.rename(dst.name, os.path.splitext(dst.name)[0])

    def extract_devices(self, devices, sizes, progress):
        """Iterate through the VMA file extents and extract the data for all block devices
           simultaneously.
        """
        total = os.fstat(self.fobj.fileno()).st_size
        while True:
            offset = self.fobj.tell()
            try:
                extent = VMAExtentHeader.read(self.fobj)
            except EOF as exc:
                # pylint:disable=raise-missing-from
                if exc.offset == offset:
                    break
                raise SystemExit(f"ERROR: corrupt file, short VMA extent at 0x{exc.offset:x}!")

            for blockinfo in extent.blockinfo:
                if blockinfo.dev_id not in devices:
                    continue

                dst = devices[blockinfo.dev_id]
                dst.seek(blockinfo.cluster_num * VMA_CLUSTER_SIZE)

                for buf in blockinfo.iterate(self.fobj):
                    if buf is not None:
                        dst.write(buf)
                    else:
                        dst.seek(4096, os.SEEK_CUR)

                if progress:
                    pos = self.fobj.tell()
                    print(f"\r  progress: {pos / total * 100:.1f}% ", end="", file=sys.stderr,
                          flush=True)

        if progress:
            print(file=sys.stderr)

        for dst, size in zip(devices.values(), sizes.values()):
            os.truncate(dst.fileno(), size)


class Main:
    """Parse command line arguments and run the specified action.
    """

    def __init__(self):
        self.args = parse_arguments()

    def run(self):
        """Run the specified action.
        """
        getattr(self, self.args.command)()

    def info(self):
        """Show detailed information about a VMA file.
        """
        with open(self.args.source, "rb") as src:
            reader = VMAReader(src)
            reader.info()

    def unpack(self):
        """Unpack the contents of a VMA file to a directory.
        """
        self._unpack(self.args.destination)

    def _unpack(self, destination, check_optimized=False):
        if self.args.verbose:
            print("read", self.args.source)
            print("  working directory:", os.path.abspath(destination))

        with open(self.args.source, "rb") as src:
            reader = VMAReader(src)
            if check_optimized and reader.header.uuid == OPTIMIZED_UUID:
                if self.args.verbose:
                    print("  INFO: archive is already optimized")
                sys.exit(0)
            reader.unpack(destination, self.args.verbose, self.args.progress)
        return reader.header.uuid, reader.header.ctime

    def pack(self):
        """Pack the contents of a directory in a VMA file.
        """
        self._pack(self.args.source, OPTIMIZED_UUID if self.args.optimize else uuid4().bytes, None)

    def _pack(self, source, uuid, ctime):
        if self.args.verbose:
            print("write", self.args.destination)
            print("  working directory:", os.path.abspath(source))

        with open(self.args.destination + ".tmp", "wb") as dst:
            writer = VMAHeader(uuid, ctime)

            names = sorted(os.listdir(source))

            # Store configuration file blobs.
            for name in names:
                if name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                if self.args.verbose:
                    print("  pack config", name)

                with open(path, "rb") as src:
                    config = src.read()
                    if name == "qemu-server.conf" and self.args.update:
                        config = Config(config)
                        for key, value in self.args.update:
                            if config.set(key, value):
                                if self.args.verbose:
                                    print(f"  update {key}={value}")
                            else:
                                if self.args.verbose:
                                    print(f"  ERROR: unable to update non-standard key {key!r}")
                        config = config.getvalue()
                    name = os.fsencode(name)
                    writer.add_config(name, config)

            # Store device name blobs.
            total = 0
            for name in names:
                if not name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                size = os.path.getsize(path)
                writer.add_device(os.fsencode(name), size)
                total += size

            dst.write(writer.render())

            # Store device files.
            dev_id = 1
            pos = 0
            for name in names:
                if not name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                if self.args.verbose:
                    print("\r  pack device", name)

                with open(path, "rb") as src:
                    extent = VMAExtentHeader(dev_id, writer.uuid, 0)
                    while True:
                        cluster = src.read(VMA_CLUSTER_SIZE)
                        if not cluster:
                            break

                        pos += VMA_CLUSTER_SIZE
                        if self.args.progress:
                            print(f"\r  progress: {pos / total * 100:.1f}% ", end="",
                                  file=sys.stderr, flush=True)

                        if extent.add(cluster):
                            dst.write(extent.render())
                            extent = VMAExtentHeader(dev_id, writer.uuid, extent.cluster_num)

                    dst.write(extent.render())

                dev_id += 1

            if self.args.progress:
                print(file=sys.stderr)

        os.rename(self.args.destination + ".tmp", self.args.destination)

    def optimize(self):
        """Unpack and repack a VMA file.
        """
        if self.args.destination is None:
            self.args.destination = self.args.source
            if self.args.verbose:
                print(f"INFO: optimize {self.args.destination} in-place")

        if self.args.tmpdir is None:
            self.args.tmpdir = os.path.dirname(self.args.destination)

        with tempfile.TemporaryDirectory(dir=self.args.tmpdir) as tmpdir:
            _, ctime = self._unpack(tmpdir, True)
            self._pack(tmpdir, OPTIMIZED_UUID, ctime)


def parse_arguments():
    """Parse and prepare command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.set_defaults(command=None, verbose=None, progress=None)
    subparsers = parser.add_subparsers()

    dump_parser = subparsers.add_parser("info",
                                help="show information and table of contents for a vma file")
    dump_parser.set_defaults(command="info")
    dump_parser.add_argument("source", help="the vma file to read")

    unpack_parser = subparsers.add_parser("unpack",
                                          help="unpack the contents of a vma file to a directory")
    unpack_parser.set_defaults(command="unpack")
    unpack_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                               default=True, help="suppress informational output")
    unpack_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                               help="suppress progress output")
    unpack_parser.add_argument("source", help="the vma file to read")
    unpack_parser.add_argument("destination", default=os.getcwd(),
                               help="extract to this directory")

    pack_parser = subparsers.add_parser("pack", help="create a vma file from a directory")
    pack_parser.set_defaults(command="pack")
    pack_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                             default=True, help="suppress informational output")
    pack_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                             help="suppress progress output")
    pack_parser.add_argument("-u", "--update", action="append", type=lambda s: split(s, "="),
                             help="update configuration entries, e.g. -u name=foobar")
    pack_parser.add_argument("-O", "--optimize", action="store_true", default=False,
                             help="optimize for better deduplication")
    pack_parser.add_argument("source", help="a directory with configuration and device files")
    pack_parser.add_argument("destination", help="the name of the target vma file")

    optimize_parser = subparsers.add_parser("optimize",
                    help="repack a vma file to optimize its deduplication properties")
    optimize_parser.set_defaults(command="optimize")
    optimize_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                                 default=True, help="suppress informational output")
    optimize_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                                 help="suppress progress output")
    optimize_parser.add_argument("-u", "--update", action="append",
                                 type=lambda s: split(s, "="),
                                 help="update configuration entries, e.g. -u name=foobar")
    optimize_parser.add_argument("-t", "--tmpdir",
                                 help="use this directory to temporarily store the vma file "\
                                      "contents, the default is the directory where the "\
                                      "target file is located")
    optimize_parser.add_argument("source", help="the vma file to read")
    optimize_parser.add_argument("destination", nargs="?",
                                 help="the name of the target vma file")

    args = parser.parse_args()

    if args.command is None:
        parser.error("choose an action")

    if args.verbose is False:
        args.progress = False
    elif args.progress is None:
        args.progress = sys.stderr.isatty()

    return args


if __name__ == "__main__":
    main = Main()
    main.run()
