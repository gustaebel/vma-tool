#!/usr/bin/env python3
#
# vma-tool - a toolbox for managing and optimizing Proxmox VMA files
#
# Copyright (c) 2025, Lars Gust√§bel
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# pylint:disable=too-many-instance-attributes

"""Manage and optimize Proxmox VMA (virtual machine archive) files.
"""

import io
import os
import sys
import time
import hashlib
import argparse
import tempfile

from uuid import UUID, uuid4

OPTIMIZED_UUID = bytes.fromhex("12345678aabbccddeeffaabbccddeeff")

VMA_CLUSTER_SIZE = 65536
VMA_HEADER_SIZE = 12288
VMA_EXTENT_HEADER_SIZE = 512
VMA_MAX_CONFIGS = 256
VMA_MAX_DEVICES = 256
VMA_BLOCKS_PER_EXTENT = 59


def md5(buf):
    """Calculate an md5 sum from a buffer.
    """
    return hashlib.md5(buf).digest()

def block512(n):
    """Round up <n> to a 512-block boundary.
    """
    return (n // 512 + 1) * 512

def split(s, sep):
    """Split a string <s> at <sep> into two parts.
    """
    return tuple(x.strip() for x in s.split(sep, 1))

def format_size(size):
    """Format <size> as a human-readable size.
    """
    for i, unit in enumerate(("TiB", "GiB", "MiB", "KiB", "B")):
        base = 1024 ** (4 - i)
        if size >= base:
            precision = 0 if unit == "B" else 1
            break
    return f"{size / base:.{precision}f} {unit}"


class _StructParser:
    """Parse a structured binary buffer.
    """
    # pylint:disable=missing-function-docstring

    def __init__(self, buf, offset=None):
        self.buf = buf
        self.offset = offset
        self.parse()

    def parse(self):
        """Parse the buffer structure.
        """
        raise NotImplementedError

    def uint(self, offset, size, byteorder="big"):
        """Read an integer at <offset> with a specified byte <size>.
        """
        return int.from_bytes(self.buf[offset:offset + size], byteorder=byteorder, signed=False)

    def uint8(self, offset):
        return self.uint(offset, 1)

    def uint16(self, offset, byteorder="big"):
        return self.uint(offset, 2, byteorder)

    def uint32(self, offset):
        return self.uint(offset, 4)

    def uint64(self, offset):
        return self.uint(offset, 8)

    def bytes(self, offset, size):
        return self.buf[offset:offset+size]

    def bytes16(self, offset):
        return self.bytes(offset, 16)

    def array(self, offset, size, func, intsize):
        a = []
        for o in range(offset, offset + size * intsize, intsize):
            a.append(func(o))
        return a


class VMADeviceInfo(_StructParser):
    """Block device information structure.
    """

    def parse(self):
        self.devname_ptr = self.uint32(0)   # blob pointer to the device name
        self.size = self.uint64(8)          # size of the device


class VMAHeader(_StructParser):
    """Global vma file header structure.
    """

    def parse(self):
        self.magic = self.bytes(0, 4)       # 'VMA\0'
        self.version = self.uint32(4)       # version 1
        self.uuid = self.bytes16(8)         # unique id, also used in extents
        self.ctime = self.uint64(24)        # creation time
        self.md5sum = self.bytes16(32)      # md5sum of the header

        self.blob_buffer_offset = self.uint32(48)   # start of the blob buffer
        self.blob_buffer_size = self.uint32(52)     # size of the blob buffer
        self.header_size = self.uint32(56)          # size of the header including the blob buffer

        self.config_names = self.array(2044, VMA_MAX_CONFIGS, self.uint32, 4)
                                            # list of blob pointers to config file names
        self.config_data = self.array(3068, VMA_MAX_CONFIGS, self.uint32, 4)
                                            # list of blob pointers to config file data

        self.dev_info = self.array(4096, 256, lambda o: VMADeviceInfo(self.buf[o:o+32], o), 32)
                                            # list of block device info structures

        if self.magic != b"VMA\0":
            raise SystemExit("ERROR: not a VMA file")

        if self.version != 1:
            raise SystemExit("ERROR: only VMA version 1 is supported!")

        if md5(self.buf[:32] + b"\0" * 16 + self.buf[48:]) != self.md5sum:
            raise SystemExit(f"ERROR: corrupt file, damaged VMA header at 0x{self.offset:x}!")


class BlobBuffer(_StructParser, dict):
    """A dictionary holding the blobs.
    """

    def parse(self):
        offset = 1
        while offset < len(self.buf):
            size = self.uint16(offset, "little")
            self[offset] = self.bytes(offset+2, size).rstrip(b"\0")
            offset += 2 + size


class Blockinfo(_StructParser):
    """Structure that holds information about one cluster of data in an extent header.
    """

    def parse(self):
        self.mask = self.uint16(0)          # bitmask 1-data 0-hole
        self.dev_id = self.uint8(3)         # device id
        self.cluster_num = self.uint32(4)   # position in the device file, in 65536-byte units


class VMAExtentHeader(_StructParser):
    """Extent header that contains up to 59 clusters with 16 4096-byte-blocks each.
    """

    def parse(self):
        self.magic = self.bytes(0, 4)       # 'VMAE'
        self.block_count = self.uint16(6)   # number of 4096-byte data blocks
        self.uuid = self.bytes16(8)         # unique id, the same as in the global header
        self.md5sum = self.bytes16(24)      # md5sum of the extent header
        self.blockinfo = self.array(40, VMA_BLOCKS_PER_EXTENT,
                                    lambda o: Blockinfo(self.buf[o:o+8], o), 8)
                                            # table of up to 59 blockinfos

        if self.magic != b"VMAE":
            raise SystemExit(f"ERROR: corrupt file, no VMA extent found at 0x{self.offset:x}!")

        if md5(self.buf[:24] + b"\0" * 16 + self.buf[40:]) != self.md5sum:
            raise SystemExit(f"ERROR: corrupt file, damaged VMA extent at 0x{self.offset:x}!")


class Config:
    """Store a qemu-server.conf configuration file data for access and modification.
    """

    def __init__(self, text):
        self.text = text

    def get(self, key, default=None):
        """Return the configuration value specified by <key>.
        """
        for line in self.text.decode("utf-8").splitlines():
            if line.startswith("#"):
                continue
            k, v = split(line, ":")
            if k == key:
                return v
        return default

    def set(self, key, value):
        """Modify the configuration <value> at <key>.
        """
        lines = []
        updated = False
        for line in self.text.decode("utf-8").splitlines():
            if not line or line.startswith("#"):
                lines.append(line)
            else:
                k, v = split(line, ":")
                if k == key:
                    updated = True
                    v = value
                lines.append(f"{k}: {v}")
        self.text = ("\n".join(lines) + "\n").encode("utf-8")
        return updated

    def getvalue(self):
        """Return the (modified) configuration file data.
        """
        return self.text


class VMAReader:
    """Read metadata and data from a Proxmox VMA file.
    """

    def __init__(self, fobj):
        self.fobj = fobj

        self.header_data = self.fobj.read(VMA_HEADER_SIZE)
        self.header = VMAHeader(self.header_data, 0)

        if self.header.magic != b"VMA\0":
            raise SystemExit("ERROR: not a VMA file")

        if self.header.version != 1:
            raise SystemExit("ERROR: only VMA version 1 is supported!")

        self.fobj.seek(self.header.blob_buffer_offset)
        self.blob_buffer_data = self.fobj.read(self.header.blob_buffer_size)
        self.blob_buffer = BlobBuffer(self.blob_buffer_data, self.header.blob_buffer_offset)

        self.configurations = {}
        for name_ptr, data_ptr in zip(self.header.config_names, self.header.config_data):
            if name_ptr == 0:
                continue
            name = os.fsdecode(self.blob_buffer[name_ptr])
            data = self.blob_buffer[data_ptr]
            self.configurations[name] = data

        self.devices = {}
        for dev_id, dev in enumerate(self.header.dev_info):
            if dev.size == 0:
                continue
            name = os.fsdecode(self.blob_buffer[dev.devname_ptr])
            self.devices[dev_id] = (name, self.header.dev_info[dev_id].size)

    def info(self):
        """Show detailed information about a VMA file.
        """
        print("filename:", self.fobj.name)
        print("version:", self.header.version)
        print("uuid:", UUID(bytes=self.header.uuid))
        print("created:", time.asctime(time.localtime(self.header.ctime)))
        print("size:", format_size(os.fstat(self.fobj.fileno()).st_size))

        for name, config in self.configurations.items():
            if name == "qemu-server.conf":
                config = Config(config)
                print("name:", config.get("name", "<unset>"))

        ordered_blocks, optimized_uuid = self.check_optimized(1024**3)
        print("optimized:", end=" ")
        if ordered_blocks:
            if optimized_uuid:
                print("yes")
            else:
                print("partially")
        else:
            print("no")
        print()

        print("configurations:")
        for name, config in self.configurations.items():
            print(f"  {name} ({format_size(len(config))})")
        print()

        print("devices:")
        for dev_id, (name, size) in self.devices.items():
            print(f"  {dev_id}: {name} ({format_size(size)})")
        print()

    def check_optimized(self, bytes_to_read=None):
        """Check if the VMA file is optimized, i.e. if the data is ordered and if it uses the
           default uuid.
        """
        optimized_uuid = self.header.uuid == OPTIMIZED_UUID

        self.fobj.seek(self.header.header_size)

        counter = {dev_id: 0 for dev_id in self.devices}
        cluster_num = {}
        while True:
            extent_data = self.fobj.read(VMA_EXTENT_HEADER_SIZE)
            if not extent_data:
                break

            extent = VMAExtentHeader(extent_data, self.fobj.tell() - VMA_EXTENT_HEADER_SIZE)

            for blockinfo in extent.blockinfo:
                dev_id = blockinfo.dev_id

                if dev_id not in self.devices:
                    continue

                mask = blockinfo.mask
                for _ in range(16):
                    if mask & 1:
                        self.fobj.read(4096)
                    mask >>= 1

                if blockinfo.cluster_num != cluster_num.get(dev_id, 0):
                    counter[dev_id] += 1

                cluster_num[dev_id] = blockinfo.cluster_num + 1

            if bytes_to_read is not None and self.fobj.tell() >= bytes_to_read:
                break

        for c in counter.values():
            if c > 0:
                return False, optimized_uuid

        return True, optimized_uuid

    def unpack(self, directory, verbose, progress):
        """Extract all the configuration files and block device files to a <directory>.
        """
        # pylint:disable=consider-using-with
        try:
            os.makedirs(directory)
        except FileExistsError:
            pass

        for name, config in self.configurations.items():
            path = os.path.join(directory, name)
            if verbose:
                print("  extract config", name)
            with open(path + ".tmp", "wb") as dst:
                dst.write(config)
            os.rename(path + ".tmp", path)

        devices = {}
        sizes = {}
        try:
            for dev_id, (name, size) in self.devices.items():
                path = os.path.join(directory, name)
                devices[dev_id] = open(path + ".tmp", "wb")
                sizes[dev_id] = size
                if verbose:
                    print(f"  extract device {dev_id} ({format_size(size)})", name)

            self.extract_devices(devices, sizes, progress)

        finally:
            for dst in devices.values():
                dst.close()
                os.rename(dst.name, os.path.splitext(dst.name)[0])

    def extract_devices(self, devices, sizes, progress):
        """Iterate through the VMA file extents and extract the data for all block devices
           simultaneously.
        """
        self.fobj.seek(self.header.header_size)

        total = os.fstat(self.fobj.fileno()).st_size
        while True:
            extent_data = self.fobj.read(VMA_EXTENT_HEADER_SIZE)
            if not extent_data:
                break
            extent = VMAExtentHeader(extent_data, self.fobj.tell() - VMA_EXTENT_HEADER_SIZE)

            for blockinfo in extent.blockinfo:
                if blockinfo.dev_id not in devices:
                    continue

                dst = devices[blockinfo.dev_id]
                dst.seek(blockinfo.cluster_num * VMA_CLUSTER_SIZE)
                mask = blockinfo.mask
                for _ in range(16):
                    if mask & 1:
                        dst.write(self.fobj.read(4096))
                    else:
                        dst.seek(4096, os.SEEK_CUR)
                    mask >>= 1

                if progress:
                    pos = self.fobj.tell()
                    print(f"\r  progress: {pos / total * 100:.1f}% ", end="", file=sys.stderr,
                          flush=True)

        if progress:
            print(file=sys.stderr)

        for dst, size in zip(devices.values(), sizes.values()):
            os.truncate(dst.fileno(), size)


class _StructBuilder:
    """Assemble a structured binary buffer.
    """
    # pylint:disable=missing-function-docstring

    def __init__(self):
        self.buffer = io.BytesIO()

    def render(self):
        """Assemble a structure using the internal buffer and return it.
        """
        raise NotImplementedError

    @property
    def size(self):
        return self.buffer.tell()

    def write(self, b):
        self.buffer.write(b)

    def skip(self, n):
        self.write(b"\0" * n)

    def uint8(self, v):
        self.write(int.to_bytes(v, 1))

    def uint16(self, v, byteorder="big"):
        self.write(int.to_bytes(v, 2, byteorder=byteorder))

    def uint32(self, v):
        self.write(int.to_bytes(v, 4))

    def uint64(self, v):
        self.write(int.to_bytes(v, 8))


class BlobBufferBuilder(_StructBuilder):
    """Assemble the blob buffer that contains configuration names and data
       and device names.
    """

    def __init__(self):
        super().__init__()
        self.write(b"\0")

    def add_string(self, s):
        """Add a null-terminated string to the blob buffer.
        """
        return self.add_blob(s + b"\0")

    def add_blob(self, s):
        """Add raw data to the blob buffer.
        """
        offset = self.size
        self.uint16(len(s), "little")
        self.write(s)
        return offset

    def render(self):
        buf = self.buffer.getvalue()
        return buf + b"\0" * (block512(len(buf)) - len(buf))


class VMABuilder(_StructBuilder):
    """Build the header structure for a Proxmox VMA file.
    """

    def __init__(self, uuid, ctime=None):
        super().__init__()

        self.uuid = uuid
        self.ctime = ctime if ctime is not None else int(time.time())

        self.blob_buffer = BlobBufferBuilder()
        self.config_names = []
        self.config_data = []
        self.dev_info = [(0, 0)]

    def add_config(self, name, data):
        """Add a configuration file to the blob buffer.
        """
        self.config_names.append(self.blob_buffer.add_string(name))
        self.config_data.append(self.blob_buffer.add_blob(data))

    def add_device(self, name, size):
        """Add a device name to the blob buffer.
        """
        self.dev_info.append((self.blob_buffer.add_string(name), size))

    def render(self):
        self.write(b"VMA\0")
        self.uint32(1)
        self.write(self.uuid)
        self.uint64(self.ctime)
        self.write(b"\0" * 16) # md5sum
        self.uint32(VMA_HEADER_SIZE)
        self.uint32(self.blob_buffer.size)
        self.uint32(VMA_HEADER_SIZE + block512(self.blob_buffer.size))

        self.skip(1984)

        for i in range(VMA_MAX_CONFIGS):
            try:
                name_ptr = self.config_names[i]
            except IndexError:
                name_ptr = 0
            self.uint32(name_ptr)

        for i in range(VMA_MAX_CONFIGS):
            try:
                data_ptr = self.config_data[i]
            except IndexError:
                data_ptr = 0
            self.uint32(data_ptr)

        self.skip(4)

        for i in range(VMA_MAX_DEVICES):
            try:
                name_ptr, size = self.dev_info[i]
            except IndexError:
                name_ptr = 0
                size = 0
            self.uint32(name_ptr)
            self.skip(4)
            self.uint64(size)
            self.skip(16)

        self.buffer.write(self.blob_buffer.render())

        buf = self.buffer.getbuffer()
        buf[32:48] = md5(buf)
        buf.release()
        return self.buffer.getvalue()


class BlockinfoBuilder:
    """Structure that holds information about one cluster of data in an extent header.
    """
    # pylint:disable=too-few-public-methods

    def __init__(self, cluster_num):
        self.cluster_num = cluster_num
        self.mask = 0
        self.blocks = []

    def add(self, block):
        """Add a block of data to the cluster.
        """
        if not block:
            # If a file does not line up to 65536 bytes,
            # we add "holes" at the end.
            block = b"\0" * 4096

        self.mask >>= 1
        if block.count(b"\0") != 4096:
            self.mask |= 1 << 15
            self.blocks.append(block)


class VMAExtentBuilder(_StructBuilder):
    """Extent header that contains structured block device file data.
    """

    def __init__(self, dev_id, uuid, cluster_num):
        super().__init__()

        self.dev_id = dev_id
        self.uuid = uuid
        self.cluster_num = cluster_num

        self.block_count = 0
        self.blockinfos = []

    def add(self, block):
        """Add a cluster of data to the extent.
        """
        blockinfo = BlockinfoBuilder(self.cluster_num)
        self.cluster_num += 1

        for i in range(16):
            offset = i * 4096
            blockinfo.add(block[offset:offset+4096])

        self.block_count += len(blockinfo.blocks)
        self.blockinfos.append(blockinfo)
        return len(self.blockinfos) == VMA_BLOCKS_PER_EXTENT

    def render(self):
        if not self.blockinfos:
            return b""

        self.write(b"VMAE")
        self.uint32(self.block_count)
        self.write(self.uuid)
        self.write(b"\0" * 16) # md5sum

        for i in range(VMA_BLOCKS_PER_EXTENT):
            try:
                blockinfo = self.blockinfos[i]
            except IndexError:
                self.uint64(0)
            else:
                self.uint16(blockinfo.mask)
                self.uint16(self.dev_id)
                self.uint32(blockinfo.cluster_num)

        buf = self.buffer.getbuffer()
        buf[24:40] = md5(buf)
        buf.release()

        for blockinfo in self.blockinfos:
            for block in blockinfo.blocks:
                self.write(block)

        return self.buffer.getvalue()


class Main:
    """Parse command line arguments and run the specified action.
    """

    def __init__(self):
        self.args = parse_arguments()

    def run(self):
        """Run the specified action.
        """
        getattr(self, self.args.command)()

    def info(self):
        """Show detailed information about a VMA file.
        """
        with open(self.args.source, "rb") as src:
            reader = VMAReader(src)
            reader.info()

    def unpack(self):
        """Unpack the contents of a VMA file to a directory.
        """
        self._unpack(self.args.destination)

    def _unpack(self, destination, check_optimized=False):
        if self.args.verbose:
            print("read", self.args.source)
            print("  working directory:", os.path.abspath(destination))

        with open(self.args.source, "rb") as src:
            reader = VMAReader(src)
            if check_optimized and reader.header.uuid == OPTIMIZED_UUID:
                if self.args.verbose:
                    print("  INFO: archive is already optimized")
                sys.exit(0)
            reader.unpack(destination, self.args.verbose, self.args.progress)
        return reader.header.uuid, reader.header.ctime

    def pack(self):
        """Pack the contents of a directory in a VMA file.
        """
        self._pack(self.args.source, OPTIMIZED_UUID if self.args.optimize else uuid4().bytes, None)

    def _pack(self, source, uuid, ctime):
        if self.args.verbose:
            print("write", self.args.destination)
            print("  working directory:", os.path.abspath(source))

        with open(self.args.destination + ".tmp", "wb") as dst:
            writer = VMABuilder(uuid, ctime)

            names = sorted(os.listdir(source))

            # Store configuration file blobs.
            for name in names:
                if name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                if self.args.verbose:
                    print("  pack config", name)
                with open(path, "rb") as src:
                    config = src.read()
                    if name == "qemu-server.conf" and self.args.update:
                        config = Config(config)
                        for key, value in self.args.update:
                            if config.set(key, value):
                                if self.args.verbose:
                                    print(f"  update {key}={value}")
                            else:
                                if self.args.verbose:
                                    print(f"  ERROR: unable to update non-standard key {key!r}")
                        config = config.getvalue()
                    name = os.fsencode(name)
                    writer.add_config(name, config)

            # Store device name blobs.
            total = 0
            for name in names:
                if not name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                size = os.path.getsize(path)
                writer.add_device(os.fsencode(name), size)
                total += size

            dst.write(writer.render())

            # Store device files.
            dev_id = 1
            pos = 0
            for name in names:
                if not name.startswith("drive-"):
                    continue

                path = os.path.join(source, name)
                if self.args.verbose:
                    print("\r  pack device", name)

                with open(path, "rb") as src:
                    extent = VMAExtentBuilder(dev_id, writer.uuid, 0)
                    while True:
                        cluster = src.read(VMA_CLUSTER_SIZE)
                        if not cluster:
                            break

                        pos += VMA_CLUSTER_SIZE
                        if self.args.progress:
                            print(f"\r  progress: {pos / total * 100:.1f}% ", end="",
                                  file=sys.stderr, flush=True)

                        if extent.add(cluster):
                            dst.write(extent.render())
                            extent = VMAExtentBuilder(dev_id, writer.uuid, extent.cluster_num)

                    dst.write(extent.render())

                dev_id += 1

            if self.args.progress:
                print(file=sys.stderr)

        os.rename(self.args.destination + ".tmp", self.args.destination)

    def optimize(self):
        """Unpack and repack a VMA file.
        """
        if self.args.destination is None:
            self.args.destination = self.args.source
            if self.args.verbose:
                print(f"INFO: optimize {self.args.destination} in-place")

        if self.args.tmpdir is None:
            self.args.tmpdir = os.path.dirname(self.args.destination)

        with tempfile.TemporaryDirectory(dir=self.args.tmpdir) as tmpdir:
            _, ctime = self._unpack(tmpdir, True)
            self._pack(tmpdir, OPTIMIZED_UUID, ctime)


def parse_arguments():
    """Parse and prepare command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.set_defaults(command=None, verbose=None, progress=None)
    subparsers = parser.add_subparsers()

    dump_parser = subparsers.add_parser("info",
                                help="show information and table of contents for a vma file")
    dump_parser.set_defaults(command="info")
    dump_parser.add_argument("source", help="the vma file to read")

    unpack_parser = subparsers.add_parser("unpack",
                                          help="unpack the contents of a vma file to a directory")
    unpack_parser.set_defaults(command="unpack")
    unpack_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                               default=True, help="suppress informational output")
    unpack_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                               help="suppress progress output")
    unpack_parser.add_argument("source", help="the vma file to read")
    unpack_parser.add_argument("destination", default=os.getcwd(),
                               help="extract to this directory")

    pack_parser = subparsers.add_parser("pack", help="create a vma file from a directory")
    pack_parser.set_defaults(command="pack")
    pack_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                             default=True, help="suppress informational output")
    pack_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                             help="suppress progress output")
    pack_parser.add_argument("-u", "--update", action="append", type=lambda s: split(s, "="),
                             help="update configuration entries, e.g. -u name=foobar")
    pack_parser.add_argument("-O", "--optimize", action="store_true", default=False,
                             help="optimize for better deduplication")
    pack_parser.add_argument("source", help="a directory with configuration and device files")
    pack_parser.add_argument("destination", help="the name of the target vma file")

    optimize_parser = subparsers.add_parser("optimize",
                    help="repack a vma file to optimize its deduplication properties")
    optimize_parser.set_defaults(command="optimize")
    optimize_parser.add_argument("-q", "--quiet", action="store_false", dest="verbose",
                                 default=True, help="suppress informational output")
    optimize_parser.add_argument("-P", "--no-progress", action="store_false", dest="progress",
                                 help="suppress progress output")
    optimize_parser.add_argument("-u", "--update", action="append",
                                 type=lambda s: split(s, "="),
                                 help="update configuration entries, e.g. -u name=foobar")
    optimize_parser.add_argument("-t", "--tmpdir",
                                 help="use this directory to temporarily store the vma file "\
                                      "contents, the default is the directory where the "\
                                      "target file is located")
    optimize_parser.add_argument("source", help="the vma file to read")
    optimize_parser.add_argument("destination", nargs="?",
                                 help="the name of the target vma file")

    args = parser.parse_args()

    if args.command is None:
        parser.error("choose an action")

    if args.verbose is False:
        args.progress = False
    elif args.progress is None:
        args.progress = sys.stderr.isatty()

    return args


if __name__ == "__main__":
    main = Main()
    main.run()
